# -*- coding: utf-8 -*-
"""AlbumPopularityScorePredictor.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vHlZdXc_HQLNLHdBiNTODoGmP-qvwC2e
"""

!pip install spotipy

import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error
import numpy as np
import pandas as pd

## Built this program with My Personal ID and Client Secret but it will be taken out for my account safety
## Can obtain yours by going to the Spotify Developers Dashbored and get yours
client_id = "1a2103e25dd347008ee2b74cdcc9544b"
client_secret = "7f483141a07c484082f429fdebbbd61b"
auth_manager = SpotifyClientCredentials(client_id=client_id, client_secret=client_secret)
sp = spotipy.Spotify(auth_manager=auth_manager)

def get_album_tracks(album_id):
    tracks = sp.album_tracks(album_id)
    for track in tracks['items']:
        print("Track: {}, Popularity: {}".format(track['name'], track['popularity']))

# Can use any artist just need to change name (no variables use the name(s) "Zach Bryan" of any other artist)
artist_name = "Drake"
results = sp.search(q='artist:' + artist_name, type='artist')
items = results['artists']['items']
if len(items) > 0:
    artist = items[0]
    artist_id = artist['id']
    print(artist_id)
else:
    print("Artist not found")
# Getting an Album from an Artist
albums = sp.artist_albums(artist_id, album_type='album')
for album in albums['items']:
    print("Album: {}, Release Date: {},Album_ID: {} ,Total Tracks: {}".format(album['name'],album["id"], album['release_date'], album['total_tracks']))
## This is Zach Bryan's artist id number
## User needs to recompile with the name they inputed
artist_id = '3TVXtAsR1Inumwj472S9r4'
albums = sp.artist_albums(artist_id=artist_id, album_type='album')

# Initialize empty lists for album and track popularities
album_popularities = []
track_popularities = []

# Assuming 'albums' is a list of album data fetched from the Spotify API
for album in albums['items']:
    # Fetch tracks of the current album
    tracks = sp.album_tracks(album['id'])
    album_tracks_popularity = []  # Temporary list to store current album's track popularities

    for track in tracks['items']:
        # Fetch detailed track information to get popularity
        track_details = sp.track(track['id'])
        track_popularity = track_details['popularity']

        # Append track popularity to the temporary list
        album_tracks_popularity.append(track_popularity)  # Corrected line

        # Append track details to the main track_popularities list
        track_popularities.append({'track_name': track['name'], 'album_name': album['name'], 'track_popularity': track_popularity})

    # Calculate the average popularity for the current album from its tracks
    if album_tracks_popularity:  # Ensure the list is not empty
        average_popularity = sum(album_tracks_popularity) / len(album_tracks_popularity)
        album_popularities.append({'album_name': album['name'], 'average_popularity': average_popularity})

# Now, if you want to print out album_popularities to see the results:
for album in album_popularities:
    print(album)
print(track_popularities)

# Convert lists to DataFrames (assuming album_popularities and track_popularities are correctly populated)
df_albums = pd.DataFrame(album_popularities)
df_tracks = pd.DataFrame(track_popularities)

# Ensure 'track_popularity' is float for accurate calculations
df_tracks['track_popularity'] = df_tracks['track_popularity'].astype(float)

# Calculate mean track popularity for each album
album_features = df_tracks.groupby('album_name', as_index=False)['track_popularity'].mean()
album_features.rename(columns={'track_popularity': 'mean_track_popularity'}, inplace=True)

# Merge album_features into df_albums on 'album_name', ensuring no duplicate mean_track_popularity columns
if 'mean_track_popularity' in df_albums.columns:
    df_albums.drop('mean_track_popularity', axis=1, inplace=True)

df_albums = pd.merge(df_albums, album_features, on='album_name', how='left')


# Split the data
X = df_albums[['mean_track_popularity']]  # Ensure this column exists in df_albums
y = df_albums['average_popularity']
## Model set up
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train the model
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Evaluate the model
# MAE used to for data to be trained on
predictions = model.predict(X_test)
mae = mean_absolute_error(y_test, predictions)
print(f'Mean Absolute Error: {mae}')

# Create a DataFrame to compare actual vs. predicted average popularity
predicted_album_pop_df = pd.DataFrame({'Actual Average Popularity': y_test, 'Predicted Average Popularity': predictions})
print(predicted_album_pop_df)

